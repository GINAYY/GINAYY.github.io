[{"title":"区块链经济学","path":"/2024/11/07/区块链经济学/","content":"宏观经济学解决三大问题：失业、通货、经济增长问题 凯恩斯主义：强调政府在经济中的作用，通过财政&amp;货币政策调节经济周期，增长需求以促进经济增长和减少失业。 主张政府应在经济低迷时通过增加公共支出、减税、扩大货币供应等方式刺激总需求，从而推动经济复苏。 凯恩斯主义失灵： 长期 vs. 短期：凯恩斯主义主要针对短期经济波动，但在长期内，经济增长往往由其他因素（如技术进步、生产力提升）主导，短期政策的有效性可能减弱。 流动性陷阱：在经济低迷时，利率可能降至接近零，消费者和投资者可能对增加支出缺乏信心，导致“流动性陷阱”现象，使得货币政策失去效力。 政府债务问题：凯恩斯主义强调通过政府支出来拉动经济，但长期的大规模赤字可能导致债务水平过高，进而限制未来政府的财政政策空间。 通货膨胀：使用凯恩斯政策刺激经济可能引发通货膨胀，尤其是在经济接近产能极限时，导致成本上升并降低购买力。 市场自我调节能力：一些学者认为市场在自由条件下具有自我调节能力，过度依赖政府干预可能导致市场失灵或资源的非有效配置。 行为经济学的视角：凯恩斯主义假设人们的决策是理性的，但行为经济学研究表明，人们的决策常常受到心理偏差和非理性因素（投资心理：波动&amp;投机）的影响，这可能导致凯恩斯政策的预期效果被削弱。 滞涨危机：经济停滞和通货膨胀经济增长乏力、高通货膨胀、高失业率 在1970年代，政府干预引发的石油危机、供应链问题及其他因素的影响，导致了严重的滞涨现象。 凯恩斯主义主要关注总需求，通过增加政府支出或降低利率来刺激经济。但滞涨往往是由供给侧问题（如能源危机或生产成本上升）引起的，单纯的需求刺激可能无法解决根本问题。 通常认为增加需求会降低失业率，但在滞涨中，增加需求可能会进一步加剧通货膨胀，而无法有效降低失业。 凯恩斯主义政策的实施时间较长，而滞涨危机往往需要迅速的反应。政策滞后可能导致措施出台时，经济形势已发生变化。 实例： 凯恩斯主义认为，通过政府支出可以刺激需求，但在滞涨情况下，这种政策可能会导致更高的通货膨胀而无助于降低失业率。 在1990年代，尽管日本政府采取了扩张性财政政策和货币政策，但经济长期停滞，消费和投资未能恢复。这表明简单的刺激措施并不足以解决深层的结构性问题。 在2008金融危机后，许多国家采取了大规模的刺激政策。然而，尽管短期内经济有所恢复，但长期的经济增长和就业改善却未如预期。部分经济学家认为，结构性改革的不足使得凯恩斯主义政策效果受到限制。 在一些国家（如日本和欧洲），央行尝试通过负利率来刺激经济。然而，实际效果往往不如预期，银行和消费者对借贷的反应不积极，导致经济增长乏力。 反对凯恩斯主义 ：解决石油危机供给学派经济增长是由供给因素（如生产要素的数量和质量）驱动的，强调降低税收和减少监管，以激励企业投资和增加生产，限制政府的财政支出，尤其是福利政策，以减少对市场的干预。关注长期经济增长，而非短期需求刺激。 供给学派质疑凯恩斯主义的短期刺激措施可能导致长期的通货膨胀和低效的资源配置。 里根经济学（Reganomics）：1980年代美国总统里根实施的经济政策，主要包括减税、减少政府干预和扩大市场自由。 货币学派认为货币供应量是影响经济活动的关键因素，控制货币供应是控制通货膨胀和促进经济增长的主要手段。 与凯恩斯主义的需求管理政策不同，货币学派反对政府对经济进行过度干预，主张中央银行应专注于稳定货币供应，防止通货膨胀。 货币学派主张，经济波动主要由货币供给的变化造成，而凯恩斯主义则过于强调需求方因素。认为凯恩斯主义强调的财政政策效果有限，且可能导致无法控制的通货膨胀。 保罗·沃尔克的货币政策：1980年代，时任美联储主席的保罗·沃尔克通过提高利率来控制高通货膨胀 奥地利经济学派奥地利学派主张强烈反对任何形式的政府干预，反对中央银行的货币政策和政府的财政刺激措施。他们认为政府的干预会扰乱市场价格机制，导致资源错配和长期的经济扭曲，认为市场可以通过自发的秩序实现资源的最优配置。 商品的价值取决于消费者对该商品的需求和欲望，而不是生产者投入的劳动或资本。 奥地利经济学派认为，市场是一种复杂的自发秩序，能够通过价格机制引导资源的最优分配。价格反映了供需之间的动态平衡，能有效协调无数个体的决策，而无需政府的中央规划。 强调人类行为的主观性，认为每个个体的行动是根据主观的目标和偏好做出的，而这些目标和偏好是动态和不可量化的。 不认为人类行为可以完全理性化，也反对将人类行为简化为纯粹的数学模型。个体根据其主观判断和有限的信息做出决策，因此不总是“理性”的。 哈耶克《货币的非国家化》 货币竞争：政府垄断货币发行的结果往往是通货膨胀、货币贬值和经济失衡。相反，如果允许私人机构或市场参与发行货币，货币的价值将更稳定，因为不受政治干预，市场会选择最可靠和最有价值的货币。 去中心化货币发行：他主张由多个机构发行不同的货币，然后让消费者和市场决定哪个货币最能保持其购买力，或者说哪个货币最值得信任。这与现代市场中的产品竞争类似，竞争会迫使货币发行者保持货币的稳定性，否则他们的货币将不被市场接受。 对抗通货膨胀：国家发行的货币受制于政治压力，政府为了短期经济或政治利益，可能会超发货币，导致通货膨胀。而在市场竞争下，发行货币的机构将有强烈的动机保持货币的稳定性，否则市场会抛弃他们的货币。 自由市场货币：哈耶克的理想是货币应该完全由自由市场来管理，而不是由政府控制。市场通过自由竞争和选择，能够自动淘汰劣质货币，选出最优的货币系统。 去中心化与竞争：哈耶克主张多种货币竞争，而比特币作为一种去中心化的数字货币，与政府发行的法定货币形成竞争。在比特币诞生后，还出现了许多其他加密货币，它们共同参与了市场上的货币竞争。这种货币的多样性和竞争性正符合哈耶克的设想。 抗通货膨胀：哈耶克担心政府会通过货币超发导致通货膨胀，而比特币的固定供应量设计正是为了解决这个问题。比特币的设计从根本上防止了货币发行的随意性，符合哈耶克对稳定货币的要求。 去中心化管理：哈耶克的理论认为货币发行应当去中心化，由多个机构竞争。虽然比特币本身没有多个发行者，但它通过区块链技术实现了去中心化的管理，全球数以万计的节点共同维护网络，避免了任何单一实体的控制。 市场驱动的货币选择：在哈耶克的理论中，市场是货币选择的最终决定者，而比特币通过市场力量逐渐获得了认可，尤其是在那些不信任政府或中央银行的地方。市场上的个人和企业可以自由选择使用比特币或其他货币，形成了哈耶克式的货币竞争环境。 《国民经济学原理》提出了边际效用的概念，解释了为什么随着物品数量的增加，个体对它的评价会逐渐递减。这一理论对商品价格的形成机制作出了重要的贡献。强调经济行为是由个体的主观选择驱动的，经济学应当从个体行为的分析出发，而不是从宏观的、整体的经济模型出发。 《人的行动》主张经济学的核心在于理解人类的有目的行为。认为人类的行动都是基于主观的偏好和目的，经济现象的本质是人类行动的结果。而不是依赖数学模型和统计分析。 《美国大萧条》罗斯巴德认为，美联储在1920年代通过人为的低利率和货币扩张，导致了金融市场的泡沫，这直接引发了1929年的股市崩盘和随后的大萧条。 社会主义计划经济存在一个关键的理论缺陷，即信息问题。这是奥地利学派对社会主义和计划经济的一个核心批判。 信息的分散性：在一个自由市场中，价格是供需关系的反映，而供需关系又是个体决策的结果。市场价格包含了关于资源的稀缺性、生产和需求的丰富信息。米塞斯和哈耶克认为，在计划经济中，中央计划者无法有效地获取和处理这些分散在社会中的信息。 无法有效分配资源：计划经济中的中央计划者试图通过集中管理经济来分配资源，但他们无法掌握市场中无数个体的需求和偏好，因为这些信息是分散和动态变化的。没有价格机制，中央计划者无法知道该生产多少、如何分配、消费者真正想要什么，这将导致资源错配和经济低效。 哈耶克的“知识问题”：弗里德里希·哈耶克进一步发展了米塞斯的观点，提出了“知识问题”，即市场中的知识是分散的，中央计划者无法集中所有必要的信息进行有效的经济决策。因此，哈耶克认为自由市场是最有效的经济体系，因为它能够通过价格机制利用分散的信息进行资源分配。 货币危机24.11.06 特朗普当选为美国第 47 任总统牛市是“钱堆出来的”。没有银行支持，大量资金无法流入Crypto市场。而且银行作为资金的主要入口，如果对Crypto保持警惕甚至设立屏障，新资金就会被阻挡在市场之外，难以形成大规模牛市。虽然美国不像大陆那样直接禁止，但银行对Crypto的态度其实是由美联储和政府间接决定的。政府、国会和美联储的监管态度直接影响银行的政策。即使Crypto在法律上并没有被禁止，银行出于谨慎，通常会选择“敬而远之”，这在实际中已经形成了不成文的准入门槛。共和党上台，尤其是特朗普这类相对更支持市场自由的总统执政，可能对金融创新更加宽容，从而放宽银行与Crypto市场的合作空间。 特朗普的经济政策被视为对加密货币市场的潜在利好 减税与加密投资 特朗普的减税政策主张降低企业所得税率并减少资本利得税。这种政策措施减少了投资者的税负，鼓励投资资本涌入高风险、高回报的市场，比如加密货币。对加密资产的投资增多，从需求角度支撑了币价上行。更低的资本利得税吸引了短期投机者的入场，加剧了市场的活跃度和波动性。 去监管与加密创新 特朗普政府多次提倡减少联邦监管，包括金融市场的监管。去监管不仅有利于企业的金融创新，同时也减少了对加密货币和区块链技术创新的限制。更多的创新型项目在宽松环境中得以发展，加密市场的生态丰富性增强，吸引投资者进入。去监管倾向与加密市场的去中心化理念高度一致，激励更多资金涌入这一领域，鼓励了加密市场的交易量和流动性。 美元地位的动摇 特朗普政府的贸易保护主义政策导致了全球市场对美元资产的不安，推动了避险资金进入加密市场。加密货币作为一种去中心化、跨境流通的资产，具备对冲美元贬值的功能。因此，贸易紧张导致的全球市场不确定性反而对比特币等去中心化资产形成了支持性需求。 财政赤字的扩张与加密需求 特朗普政府的财政扩张政策和减税策略加剧了财政赤字，加之疫情带来的大规模支出导致美联储不断扩表。由于凯恩斯主义的政策刺激需要不断的财政支出，加之贸易政策冲突，政府赤字上升，市场对美元资产的信心下滑。去中心化的加密货币提供了对抗政府债务扩张导致的通货膨胀的资产选择。 去中心化货币对抗通胀 凯恩斯主义依赖于政府支出以刺激需求，虽然短期内能够刺激经济增长，但在长期中可能导致高通胀和流动性陷阱。特朗普政策进一步扩展了赤字，加密货币尤其是比特币因此被视作“数字黄金”，成为对抗通胀和美元贬值的工具。比特币和其他稀缺性较强的加密资产在这种环境下成为了保值的首选，增强了其投资吸引力。 &#x20;避险资产的多元化需求 特朗普政府的政策对全球经济和金融市场造成了影响，加剧了市场波动性。尤其是在对美联储的公开压力和利率政策上的干涉，使得投资者对传统金融体系的稳定性有所疑虑。加密货币作为去中心化资产，可以对冲市场的不确定性。对冲基金和高净值投资者逐渐增配加密货币，以多元化投资组合对冲风险，促进了机构资本入场。 奥地利学派经济学的呼应：市场选择与去中心化 特朗普上任期间，更多自由市场和去中心化经济的理念进入主流讨论，增强了加密货币市场的合法性。从奥地利学派角度，去中心化货币如比特币符合哈耶克“货币非国家化”的思想：政府发行的法币由于受到政府开支和货币扩张政策的影响，可能出现通胀；相比之下，加密货币具备去中心化和透明的特点，其数量通常固定，不受单一国家政策干预。 免责声明：根据央行等部门发布“关于进一步防范和处置虚拟货币交易炒作风险的通知”，本文内容仅用于信息分享，本文内容均不构成任何投资建议。不对任何经营与投资行为进行推广与背书，请读者严格遵守所在地区法律法规，不参与任何非法金融行为。","tags":["blockchain"],"categories":["web3"]},{"title":"PicGo+Github搭建图床","path":"/2024/11/06/PicGo-Github搭建图床/","content":"安装PicGohttps://github.com/Molunerfinn/PicGo/releases 安装完在桌面点了好几次没反应，反复卸载，最后看文档才发现是在状态栏处打开。 https://picgo.github.io/PicGo-Doc/zh/guide/#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85 配置GitHub仓库为了使用GitHub作为图床，你需要一个GitHub仓库来存放图片，确保仓库的权限设置为公开，这样别人才能访问你的图片。 生成Personal Access Token (PAT)为了使PicGo能够访问你的GitHub仓库，你需要生成一个Personal Access Token： 登录你的GitHub账户。 访问设置页面，找到“Developer settings”部分。 在“Personal access tokens”中生成一个新的访问令牌。 确保你的访问令牌具有足够的权限来推送到仓库（至少需要repo权限）。 生成后，确保复制并保存你的访问令牌，因为它不会再次显示。 配置PicGo 在PicGo的设置中找到“图床设置”。 选择“GitHub”作为图床服务。 输入你的GitHub仓库名称（格式为username/repo）。 输入你的Personal Access Token。 配置分支名称，默认为main或master。 配置路径前缀，这是你图片存放在GitHub仓库中的目录路径。 保存设置。 PicGo 插件https://github.com/PicGo/Awesome-PicGo vscode-migrator 0.0.2 功能：从 Visual Studio Code 的图片上传插件（如 PicGo 的 VS Code 插件）导入图片。 quick-capture 1.0.0-alpha.2 功能：一个快速截图插件，用于 PicGo，允许用户快速捕捉屏幕并上传图片。 https://github.com/PicGo/picgo-plugin-quick-capture 点击链接看教程 pic-migrator 1.3.2 功能：一个 PicGo 插件，用于在 Markdown 文件中迁移图片链接。 super-prefix 1.2.2 功能：一个 PicGo 插件，用于为上传的文件名添加优雅的前缀。 https://github.com/gclove/picgo-plugin-super-prefix#readme Picgo-plugin-clipboard 功能：允许你将剪贴板中的图片直接上传到配置的图床 可以愉快的使用了","tags":["PicGo","Github"],"categories":["工具"]},{"title":"Git学习","path":"/2024/11/06/Git学习/","content":"Git原理123代码块1代码块2代码块3 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;void dfs()&#123; // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;&#125;int main()&#123; dfs(); return 0;&#125;","tags":["Git"]},{"title":"Hello World","path":"/2024/11/06/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartHEXO无后端运维和高速渲染页面是静态站点生成器,我使用了 Github Pages 和 Vercel 来部署博客 Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"Markdown格式","path":"/2024/10/11/Markdown/","content":"123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 一级标题二级标题三级标题四级标题五级标题六级标题1###### tags: `This is tag` tags: This is tag列表无序列表：*，+，- 表示无序列表。注意：符号后面一定要有一个空格，起到缩进的作用 123- 列表1 - 列表2- 列表3 列表1 列表2 列表3 有序列表：英文句点后面一定要有一个空格 1231. 列表12. 列表23. 列表3 列表1 列表2 列表3 123&gt; 引用1&gt; 引用2&gt; 引用3 引用1引用2引用3 1 代码块 1 123代码块1代码块2代码块3 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;void dfs()&#123; // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;&#125;int main()&#123; dfs(); return 0;&#125; 123![图片描述](https://www.example.com/image.jpg) 点击图片可放大1&#123;% image /路径/路径.jpg %&#125; 插入链接12[链接](URL_ADDRESS) markdown教程 强调语法12345678*斜体文本*_斜体文本_**粗体文本**__粗体文本__**_同时斜体和粗体_** 斜体文本斜体文本 粗体文本粗体文本 同时斜体和粗体 任务列表123- [x] 已完成项- [ ] 未完成项 已完成项 未完成项 表格123456| 表头 | 表头 || ---- | ---- || 单元 | 单元 || 单元 | 单元 | 表头 表头 单元 单元 单元 单元 水平分隔线1234567三个或三个以上的符号，必须在独立的一行，前后不能有其他文字--- 短横线***星号___下短线 短横线 星号 下短线","tags":["Markdown"],"categories":["工具"]},{"title":"about","path":"/about/index.html","content":"GinaA lifelong journey of learning and creating"},{"path":"/js/adjust-codeblock-height.js","content":"// 给超长代码块增加滚动条 function adjustCodeBlockHeight() { document.addEventListener(\"DOMContentLoaded\", function () { // 选择所有的.md-text元素 var codeBlocks = document.querySelectorAll('.md-text'); // 遍历每个.md-text元素 codeBlocks.forEach(function (block) { // 检查是否包含.highlight类的子元素，且父元素高度超过500px var highlightBlocks = block.querySelectorAll('.highlight'); highlightBlocks.forEach(function (highlightBlock) { if (highlightBlock.clientHeight > 100) { highlightBlock.style.maxHeight = '300px'; highlightBlock.style.overflow = 'auto'; } }); }); }); } adjustCodeBlockHeight()"},{"path":"/js/l2d.js","content":"addEventListener(\"DOMContentLoaded\", function () { let models = [ { width: 230, height: 350, bottom: \"0px\", right: \"0px\", role: \"https://cdn.jsdelivr.net/gh/imuncle/live2d@master/model/snow_miku/model.json\", background: \"\", opacity: 1, mobile: false, draggable: false, scale: 0.07, }, ]; new Live2dLoader(models); });"},{"path":"/js/chatgpt.js","content":"function ChucklePostAI(config) { // 获取要插入 AI 的文章容器 function getArticleContainer() { let container = null; if (!config.auto_mount && config.el) { container = document.querySelector( config.el || \"#post #article-container\" ); } return container || findLargestContentElement(); } // 计算一个元素的子元素的数量 function countChildElements(element) { let count = 1; Array.from(element.children).forEach((child) => { count += countChildElements(child); }); return count; } // 检查一个元素是否应被排除（如 iframe、footer 等） function shouldExcludeElement(element) { const tagBlacklist = [\"IFRAME\", \"FOOTER\", \"HEADER\", \"BLOCKQUOTE\"]; const classBlacklist = [\"aplayer\", \"comment\"]; return ( tagBlacklist.includes(element.tagName) || Array.from(element.classList).some((className) => classBlacklist.some((cls) => className.includes(cls)) ) ); } // 查找内容最多的 DOM 元素 function findLargestContentElement() { const rootElement = findRootElement(); return findLargestElementInTree(rootElement); } // 查找内容最多的根元素 function findRootElement() { const elementsToCheck = [document.body]; let rootElement = null; let maxCount = 0; while (elementsToCheck.length > 0) { const element = elementsToCheck.shift(); if (shouldExcludeElement(element)) continue; const childCount = countChildElements(element); if (childCount > maxCount) { maxCount = childCount; rootElement = element; } Array.from(element.children).forEach((child) => { elementsToCheck.push(child); }); } return rootElement; } // 查找最大的 DOM 元素 function findLargestElementInTree(rootElement) { const weightMap = { H1: 1.5, H2: 1, H3: 0.5, P: 1 }; let maxWeight = 0; let largestElement = null; function calculateWeight(element) { if (shouldExcludeElement(element)) return; let elementWeight = Array.from(element.children).reduce( (weight, child) => { return weight + (weightMap[child.tagName] || 0); }, 0 ); if (elementWeight > maxWeight) { maxWeight = elementWeight; largestElement = element; } Array.from(element.children).forEach(calculateWeight); } calculateWeight(rootElement); return largestElement; } // 创建并插入 AI 的 UI 元素 function createAIElement() { const aiContainer = document.createElement(\"div\"); aiContainer.className = \"post-ai\"; aiContainer.id = \"post-ai\"; aiContainer.style.cssText = ` margin: 30px 0; `; const aiInterface = { name: \"文章辅助AI\", introduce: \"我是文章辅助AI，点击下方的按钮，让我生成本文简介\", version: \"gpt-3.5-turbo-16k\", buttons: [\"介绍自己\", \"生成摘要\"], ...config.interface, }; aiContainer.innerHTML = ` ${aiInterface.name} 切换简介 ${aiInterface.version} ${aiInterface.name}初始化中... ${aiInterface.buttons .map((btn) => `${btn}`) .join(\"\")} `; bindButtonEvents(aiContainer); const articleContainer = getArticleContainer(); if (articleContainer) { articleContainer.insertBefore(aiContainer, articleContainer.firstChild); } disableButtons(aiContainer); // 禁用按钮 generateSummary(aiContainer); // 初始化时生成文章摘要 } // 绑定按钮事件 function bindButtonEvents(aiContainer) { const generateIntroductionButton = aiContainer.querySelector( \".ai-btn-item:first-child\" ); const generateSummaryButton = aiContainer.querySelector( \".ai-btn-item:last-child\" ); generateIntroductionButton.addEventListener(\"click\", () => { disableButtons(aiContainer); // 禁用按钮 displaySummary( \"我是文章辅助AI，使用的OpenAI的gpt-3.5-turbo, embedding, gpt-4o-mini, gpt-4模型。点击下方的按钮，让我生成本文简介。\", aiContainer ); }); generateSummaryButton.addEventListener(\"click\", () => { disableButtons(aiContainer); // 禁用按钮 generateSummary(aiContainer); // 将 aiContainer 传递给 generateSummary }); } // 禁用所有按钮 function disableButtons(aiContainer) { const buttons = aiContainer.querySelectorAll(\".ai-btn-item\"); buttons.forEach((button) => { button.disabled = true; button.style.pointerEvents = \"none\"; // 禁用点击事件 button.style.opacity = \"0.5\"; // 调整按钮的透明度 }); } // 启用所有按钮 function enableButtons(aiContainer) { const buttons = aiContainer.querySelectorAll(\".ai-btn-item\"); buttons.forEach((button) => { button.disabled = false; button.style.pointerEvents = \"auto\"; // 允许点击事件 button.style.opacity = \"1\"; // 恢复按钮的透明度 }); } // 生成文章摘要 async function generateSummary(aiContainer) { const content = getArticleContent(); const apiKey = \"sk-X0SGzTCLenEtBroX1Nm5nItG1iYP32zAtUKyyT2im62MYWFD\"; // 请替换为你的实际 API KEY const requestBody = { model: \"gpt-3.5-turbo-16k\", messages: [ { role: \"system\", content: \"请为下面的内容生成摘要，以本文讲述了开头，不要出现任何与文章无关的内容。\", }, { role: \"user\", content: content }, ], temperature: 0, }; try { const response = await fetch(\"https://api.chatanywhere.tech\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\", Authorization: `Bearer ${apiKey}`, }, body: JSON.stringify(requestBody), }); if (!response.ok) { throw new Error(\"网络响应不是 OK\"); } const data = await response.json(); displaySummary(data.choices[0].message.content, aiContainer); console.log(\"摘要生成成功:\", data.choices[0].message.content); } catch (error) { console.error(\"请求失败:\", error); } } // 获取文章内容 function getArticleContent() { const articleContainer = getArticleContainer(); return articleContainer ? articleContainer.innerText : \"\"; // 获取文章的文本内容 } // 显示生成的摘要（添加打字机效果） function displaySummary(summary, aiContainer) { const aiSpeechContent = document.querySelector(\".ai-explanation\"); if (aiSpeechContent) { aiSpeechContent.innerText = \"\"; // 清空之前的内容 typeWriterEffect(aiSpeechContent, summary, 15, aiContainer); // 逐字显示摘要 } } // 打字机效果 function typeWriterEffect(element, text, delay, aiContainer) { let index = 0; function type() { if (index < text.length) { element.innerText += text.charAt(index); index++; setTimeout(type, delay); } else { enableButtons(aiContainer); // 打字效果结束后启用按钮 } } type(); } // 初始化函数 function initialize() { createAIElement(); } initialize(); }"},{"title":"Go基础语法","path":"/wiki/Go/基础语法/index.html","content":"变量 变量名必须以字母开头，可以包含字母、数字和下划线。 变量名不能以数字开头。 1234var 变量名 变量类型var name stringvar age int 12345var 变量名 类型 = 表达式var a int = 10var name string = &quot;yy&quot;//多个变量声明var x, y, z int = 1, 2, 3 123456789//自动类型推断： Go 允许根据初始值推断变量类型var a = 42 // 编译器推断 a 的类型为 intvar b = 3.14 // 编译器推断 b 的类型为 float64var c = &quot;hello&quot; // 编译器推断 c 的类型为 string//类型推断的前提是必须有初始化值。如果没有初始化值，编译器将无法推断类型。//例如，以下代码会报错： var a // 错误：编译器无法推断类型 推断类型与字面值一致。 12345c := 3.14 //使用 := 来给变量赋值,仅限于函数内使用d := 42 // 编译器推断 d 的类型为 inte := 3.14 // 编译器推断 e 的类型为 float64f := true // 编译器推断 f 的类型为 bool 1234567//批量声明var ( a string b int c bool d float32 ) 123456789101112131415161718//匿名变量package mainimport &quot;fmt&quot;func main() &#123; // 使用匿名变量存储函数参数 var _ = &quot;Hello, World!&quot; fmt.Println(_) // 打印匿名变量的值 // 使用匿名变量存储计算结果 var _, _ = 1, 2 fmt.Println(_, _) // 打印两个匿名变量的值&#125;//由于匿名变量没有名字，它们不会占用命名空间，因此它们之间不存在重复声明的问题//在 Go 中，匿名变量主要用于函数内部，以避免污染全局命名空间。 变量的零值 整型： int 类型的零值是 0。 uint 类型的零值是 0。 浮点型： float32 类型的零值是 0.0。 float64 类型的零值是 0.0。 布尔型： bool 类型的零值是 false。 字符串： string 类型的零值是空字符串 &quot;&quot;。 指针： 指针类型的零值是 nil。 切片： 切片类型的零值是空切片 []。 映射： 映射类型的零值是空映射 map&#123;&#125;。 通道： 通道类型的零值是 nil。 结构体： 结构体类型的零值是零值是结构体的零初始化，例如 struct&#123;&#125;。 接口： 接口类型的零值是 nil。 常量常量用于存储固定不变的值，其值在程序运行期间不能改变。使用 const 关键字声明常量。 声明了pi和e这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了 12const pi = 3.1415const e = 2.7182 枚举常量12345const ( A = iota // 0 B = iota // 1 C = iota // 2) 123456const ( n1 = iota //0 n2 //1 _ n4 //3 ) 1234567const ( n1 = iota //0 n2 = 100 //100 n3 = iota //2 n4 //3 )const n5 = iota //0 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; const ( a = iota // 这是第一次使用 iota，所以 a = 0 b // 这是第二次使用 iota，所以 b = 1 c // 这是第三次使用 iota，所以 c = 2 d = &quot;ha&quot; // 这里没有使用 iota，所以 iota 的计数器不会增加 e // 这是第四次使用 iota，所以 e = 0（因为上一次赋值重置了 iota） f = 100 // 这里没有使用 iota，所以 iota 的计数器不会增加 g // 这是第五次使用 iota，所以 g = 1（继续上一次的计数） h = iota // 这里显式地使用 iota，所以 h = 7（因为这是新的一轮，从0开始，然后增加7次） i // 这是第六次使用 iota，所以 i = 8 ) fmt.Println(a, b, c, d, e, f, g, h, i)&#125; 常量和变量在内存区域的存储Go 内存区域划分Go 语言中，内存通常分为三大区域： 全局静态区：存储全局变量和常量。这些变量和常量在程序启动时分配内存，并在程序结束时释放。 就像是家里的储藏室，存放不常变动的东西。 堆：存储动态分配的内存，通常用于需要在多个函数间共享的对象。堆上的数据需要手动管理或由 Go 的垃圾回收机制负责清理。 栈：用于函数调用时 栈与堆的差异 变量的内存存储 全局变量：全局变量声明在函数外，属于静态存储区，存储在全局静态区中。这些变量在程序启动时被分配，程序结束时被释放。全局变量的生命周期与程序的生命周期相同，程序一启动就会分配存储空间，直到程序结束。 局部变量：局部变量是在函数内部声明的，它们通常存储在栈上（如果不逃逸）。当函数调用时，栈帧会为局部变量分配内存；当函数返回时，这些栈内存会自动释放。如果局部变量逃逸到堆中，那么数据会存储在堆上。作用域：从定义哪一行开始直到与其所在的代码块结束 指针变量：指针变量存储在栈上或堆上，但它们指向的数据可以位于堆中。如果变量逃逸到堆中，那么数据会存储在堆上。 常量的内存存储 编译时常量：常量使用 const 关键字声明，它们通常在编译时确定，并且不会在运行时分配实际的存储空间。常量在内存中的表现方式与字面量类似，在很多情况下，编译器会直接将常量的值内联到使用它的地方。由于常量的值在编译时确定，因此它们不会像变量一样占用运行时内存。 只读常量：对于某些复杂常量（例如字符串），它们会存储在只读的内存区，通常位于全局静态区中。尽管这些常量不会在运行时更改，它们可能仍然占用一些内存资源。 内存逃逸分析在Go语言中，逃逸分析（escape analysis）是一种编译期优化技术，用于确定局部变量的存储位置。如果变量只在当前函数内部使用，并且没有被传递到其他函数或goroutine，那么这个变量通常存储在栈（stack）上。如果变量的生命周期超出了当前函数，比如被返回或传递给了其他goroutine，那么这个变量就会“逃逸”到堆（heap）上。 让我们用大白话来解释一下这个过程： 逃逸分析是什么？逃逸分析就像是侦探工作，编译器像侦探一样，追踪每个局部变量的去向。如果变量只在当前函数内部使用，那么它就老老实实地呆在栈上。但如果变量被带出了当前函数，比如被函数返回，或者被发送到另一个goroutine，那么它就需要一个更长久的家——堆。 为什么变量会逃逸到堆上？ 变量被返回： 如果一个变量的地址被返回，那么它可能被其他函数长时间持有，所以它需要存储在堆上，以免在函数返回后被销毁。 变量被传递给goroutine： 如果一个变量被传递给一个新的goroutine，那么它的生命周期就不再局限于当前函数，它需要在堆上分配内存，以确保在goroutine执行期间变量仍然有效。 什么时候会发生： 如果局部变量的生命周期超出了它所在的函数，比如被函数返回或者被传递给了其他的goroutine，那么它就需要一个更长久的存储位置，这时候它就会“逃逸”到堆上。 堆的作用： 堆就像是家里的储藏室，用来存放那些需要长时间保存的东西。在Go语言中，当局部变量逃逸到堆上时，就意味着它们被分配在堆上，可以被程序的其他部分长期访问。 1234func escapeExample() *int &#123; var x int = 42 // x 在栈上分配 return &amp;x // x 的地址被返回，x 逃逸到堆上&#125; Go数据类型 1234567891011121314151617181920212223242526272829303132333435363738package mainimport &quot;fmt&quot;func main() &#123; var intV int // 整型变量 var floatV float32 // 实型变量 var boolV bool // 布尔型变量 var stringV string // 字符串变量 var pointerV *int // 指针变量 var funcV func(int, int)int // function变量 var interfaceV interface&#123;&#125; // 接口变量 var sliceV []int // 切片变量 var channelV chan int // channel变量 var mapV map[string]string // map变量 var errorV error // error变量 fmt.Println(&quot;int = &quot;, intV) // 0 fmt.Println(&quot;float = &quot;, floatV) // 0 fmt.Println(&quot;bool = &quot;, boolV) // false fmt.Println(&quot;string = &quot;, stringV) // &quot;&quot; fmt.Println(&quot;pointer = &quot;, pointerV) // nil fmt.Println(&quot;func = &quot;, funcV) // nil fmt.Println(&quot;interface = &quot;, interfaceV) // nil fmt.Println(&quot;slice = &quot;, sliceV) // [] fmt.Println(&quot;slice = &quot;, sliceV == nil) // true fmt.Println(&quot;channel = &quot;, channelV) // nil fmt.Println(&quot;map = &quot;, mapV) // map[] fmt.Println(&quot;map = &quot;, mapV == nil) // true fmt.Println(&quot;error = &quot;, errorV) // nil var arraryV [3]int // 数组变量 type Person struct&#123; name string age int &#125; var structV Person // 结构体变量 fmt.Println(&quot;arrary = &quot;, arraryV) // [0, 0, 0] fmt.Println(&quot;struct = &quot;, structV) // &#123;&quot;&quot; 0&#125;&#125; 复合数据类型数组（Array）数组是具有固定长度的同类型元素集合。一旦定义，数组的长度就固定，不能改变。 12var arr [5]int = [5]int&#123;1, 2, 3, 4, 5&#125; // 定义一个长度为5的整型数组balance := [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125; 如果数组长度不确定，可以使用 … 代替数组的长度，编译器会根据元素个数自行推断数组的长度： 12var balance = [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;balance := [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125; 遍历数组 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; arr := [...]int&#123;1, 3, 5&#125; // 传统for循环遍历 for i:=0; i&lt;len(arr); i++&#123; fmt.Println(i, arr[i]) &#125; // for...range循环遍历 for i, v := range arr&#123; fmt.Println(i, v) &#125;&#125; 二维数组 12345678910package mainimport &quot;fmt&quot;func main() &#123; // 创建一个两行三列数组 arr := [2][3]int&#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, //注意: 数组换行需要以逗号结尾 &#125; fmt.Println(arr)// [[1 2 3] [4 5 6]] &#125; 12345678910package main import &quot;fmt&quot; func main() &#123; // 创建一个两行三列数组 arr := [...][3]int&#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#125; fmt.Println(arr)// [[1 2 3] [4 5 6]] &#125; 切片（Slice）切片是基于数组的动态数组，长度可以变化，切片不需要指定长度，可以动态扩展。 12var slice []int = []int&#123;1, 2, 3&#125;slice = append(slice, 4) // 动态扩展切片 make函数创建 make(类型, 长度, 容量) 内部会先创建一个数组, 然后让切片指向数组 如果没有指定容量,那么容量和长度一样 12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; // 第一个参数: 指定切片数据类型 // 第二个参数: 指定切片的长度 // 第三个参数: 指定切片的容量 var sce = make([]int, 3, 5) fmt.Println(sce) // [0 0 0] fmt.Println(len(sce)) // 3 fmt.Println(cap(sce)) // 5 /* 内部实现原理 var arr = [5]int&#123;0, 0, 0&#125; var sce = arr[0:3] */&#125; 123456var slice4 []int = []int&#123;1,2,3,4,5&#125;var slice5 = make([]int,10)copy(slice5,slice4) //将切片slice4拷贝为slice5fmt.Println(slice4) //1,2,3,4,5fmt.Println(slice5) //1,2,3,4,5,0,0,0,0,0//默认情况下，使用make后，多余的空间默认为0 12345type slice struct&#123; array unsafe.Pointer // 指向底层数组指针 len int // 切片长度(保存了多少个元素) cap int // 切片容量(可以保存多少个元素)&#125; 1234567891011121314151617package mainimport(&quot;fmt&quot;)func main()&#123; var intArr [5]int = [...]int&#123;11,22,33,44,55&#125; //数组 slice := intArr[1:3] fmt.Println(&quot;intarr=&quot;,intArr) //intArr= [11 22 33 4 55] fmt.Println(&quot;intarr的容量是 &quot;,len(inArr)) //intArr的容量是 5 fmt.Println(&quot;slice 的元素是 &quot;,slice) //slice 的元素是 [22 33] //数组的第二个元素（下标为 1）到第三个元素（下标为 3）的切片。 //切片不包含第四个元素（下标为 3） fmt.Println(&quot;slice 的容量是&quot;,cap(slice)) //slice 的容量是 2 //切片的容量是可变的，这意味着你可以在切片的生命周期内增加切片的长度。 //切片的长度是不可变的，但是你可以在切片上添加或删除元素，从而改变切片的长度。 fmt.Println(&quot;slice 的元素个数为&quot;,len(slice)) //slice 元素个数为 2 &#125; 字典（Map）字典是一种键值对数据结构，用于高效地存储和检索元素。 12//map格式:var dic map[key数据类型]value数据类型var m map[string]int = map[string]int&#123;&quot;foo&quot;: 1, &quot;bar&quot;: 2&#125; map的增删改查 增加 当 map 中没有指定的键时，就会自动增加键值对。 12345678910package mainimport &quot;fmt&quot;func main() &#123; var dict = make(map[string]string) fmt.Println(&quot;增加前:&quot;, dict) // map[] dict[&quot;name&quot;] = &quot;ln&quot; fmt.Println(&quot;增加后:&quot;, dict) // map[name:ln]&#125; 修改 当 map 中有指定的键时，就会自动修改键对应的值。 12345678910package mainimport &quot;fmt&quot;func main() &#123; var dict = map[string]string&#123;&quot;name&quot;: &quot;ln&quot;, &quot;age&quot;: &quot;3&quot;, &quot;gender&quot;: &quot;male&quot;&#125; fmt.Println(&quot;修改前:&quot;, dict) // map[name:ln age:3 gender:male] dict[&quot;name&quot;] = &quot;zs&quot; fmt.Println(&quot;修改后:&quot;, dict) // map[name:zs age:3 gender:male]&#125; 删除 可以通过 Go 语言内置的 delete 函数删除指定键的元素。 123456789101112package mainimport &quot;fmt&quot;func main() &#123; var dict = map[string]string&#123;&quot;name&quot;: &quot;ln&quot;, &quot;age&quot;: &quot;3&quot;, &quot;gender&quot;: &quot;male&quot;&#125; fmt.Println(&quot;删除前:&quot;, dict) // map[name:ln age:3 gender:male] // 第一个参数: 被操作的字典 // 第二个参数: 需要删除元素对应的键 delete(dict, &quot;name&quot;) fmt.Println(&quot;删除后:&quot;, dict) // map[age:3 gender:male]&#125; 查询 通过 ok-idiom 模式判断指定键值是否存储。 12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; var dict = map[string]string&#123;&quot;name&quot;: &quot;ln&quot;, &quot;age&quot;: &quot;3&quot;, &quot;gender&quot;: &quot;male&quot;&#125; // value, ok := dict[&quot;age&quot;] //if(ok)&#123; // fmt.Println(&quot;有age这个key,值为&quot;, value) //&#125;else&#123; // fmt.Println(&quot;没有age这个key,值为&quot;, value) // &#125; if value, ok := dict[&quot;age&quot;]; ok&#123; fmt.Println(&quot;有age这个key,值为&quot;, value) fmt.Println(&quot;没有age这个key,值为&quot;, !ok)&#125; 遍历 遍历 map 时，map 中存储的数据是无序的，所以多次输出的顺序可能不同。 1234var dict = map[string]string&#123;&quot;name&quot;: &quot;ln&quot;, &quot;age&quot;: &quot;3&quot;, &quot;gender&quot;: &quot;male&quot;&#125;for key, value := range dict &#123; fmt.Println(key, value)&#125; 结构体（Struct）结构体是一种复合数据类型，用于将不同类型的数据组合在一起。 12345type Person struct &#123; Name string // 结构体类型中的字段 Age int&#125; 指针（Pointer）指针存储变量的内存地址。Go 不支持指针运算，但可以通过指针来改变原变量的值。 123var x int = 10var p *int = &amp;x // p 存储 x 的内存地址*p = 20 // 修改 x 的值为 20 特殊数据类型接口（Interface）接口定义了一组方法，而不实现这些方法。实现接口的具体类型必须实现接口中定义的所有方法。 123type Speaker interface &#123; Speak()&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport &quot;fmt&quot;// 1.定义一个接口type usber interface &#123; start() stop()&#125;type Computer struct &#123; name string model string&#125;// 2.实现接口中的所有方法func (cm Computer)start() &#123; fmt.Println(&quot;启动电脑&quot;)&#125;func (cm Computer)stop() &#123; fmt.Println(&quot;关闭电脑&quot;)&#125;type Phone struct &#123; name string model string&#125;// 2.实现接口中的所有方法func (p Phone)start() &#123; fmt.Println(&quot;启动手机&quot;)&#125;func (p Phone)stop() &#123; fmt.Println(&quot;关闭手机&quot;)&#125;// 3.使用接口定义的方法func working(u usber) &#123; u.start() u.stop()&#125;func main() &#123; cm := Computer&#123;&quot;戴尔&quot;, &quot;F1234&quot;&#125; working(cm) // 启动电脑 关闭电脑 p := Phone&#123;&quot;华为&quot;, &quot;M10&quot;&#125; working(p) // 启动手机 关闭手机&#125; 函数（Function）函数在 Go 中也是一种数据类型，可以作为参数或返回值传递给其他函数。 123func add(a, b int) int &#123; return a + b&#125; 通道（Channel）通道是 Go 语言中的一种用于并发的类型，用于在 goroutine 之间传递数据。 12345ch := make(chan int)go func() &#123; ch &lt;- 42 // 发送数据到通道&#125;()data := &lt;-ch // 从通道接收数据 数据类型转换Go 是静态类型语言，必须显式地进行类型转换，不能像某些动态语言一样自动进行隐式类型转换。 12var a int = 10var b float64 = float64(a) // int 转换为 float64 运算符 Go语言中++、–运算符不支持前置 错误写法: ++i; –i; Go语言中++、–是语句,不是表达式,所以必须独占一行 错误写法: a &#x3D; i++; return i++; 123456789101112a := 6 // 110 in binaryb := 3 // 011 in binaryfmt.Println(a &amp; b) // 结果为2 （010 in binary）//只有当两个操作数的对应位都为1时，结果位才为1。因此，结果为 010（十进制下为2）fmt.Println(a | b) // 结果为7 （111 in binary）//只要两个操作数的对应位有一个为1，结果位就为1。因此，结果为 111（十进制下为7）fmt.Println(a ^ b) // 结果为5 （101 in binary）//只要两个操作数的对应位不同，结果位就为1。因此，结果为 101（十进制下为5）fmt.Println(a &lt;&lt; 1) // 结果为12 （1100 in binary）//a &lt;&lt; 1 将 a 的二进制表示 110 向左移动1位，相当于乘以2的1次方。因此，结果为 1100（十进制下为12fmt.Println(b &gt;&gt; 1) // 结果为1 （001 in binary）//b &gt;&gt; 1 将 b 的二进制表示 011 向右移动1位，相当于除以2的1次方。因此，结果为 001（十进制下为1） 123456789101112 package mainimport &quot;unsafe&quot;const ( a = &quot;abc&quot; b = len(a) c = unsafe.Sizeof(a)) func main()&#123; println(a, b, c) &#125;//以上实例运行结果为：abc 3 16 流程控制常见的分支控制语句包括 if、else、switch、select&#x20; for 循环：Go 中的循环结构主要通过 for 语句实现。Go 没有像其他语言中的 while 和 do-while 循环，而是用 for 语句可以完成所有的循环需求。 123456for i := 0; i &lt; 5; i++ &#123; if i == 3 &#123; continue // 跳过 i 等于 3 的那次循环 &#125; fmt.Println(i)&#125; for…range 循环：for...range 循环用于遍历数组、切片（slice）、map、字符串等集合类型的数据。 1234nums := []int&#123;1, 2, 3, 4, 5&#125;for index, value := range nums &#123; fmt.Printf(&quot;索引: %d, 值: %d &quot;, index, value)&#125; select 语句：是 Go 特有的，用于处理多个通道（channel）的通信操作。它类似于 switch，但每个 case 都必须是一个通道操作。 12345678select &#123;case &lt;-ch1: // 如果 ch1 通道可读取数据，执行此代码块case ch2 &lt;-: // 如果 ch2 通道可写入数据，执行此代码块default: // 如果没有通道可用，执行此代码块&#125; 循环配合 defer 使用：在循环中，defer 语句会在当前函数返回之前按照后进先出的顺序执行。通常用于在循环中执行一些延迟操作比如文件关闭、资源释放等。 123for i := 0; i &lt; 3; i++ &#123; defer fmt.Println(&quot;延迟执行:&quot;, i)&#125; 嵌套循环：Go 允许在循环内嵌套其他循环，以实现更复杂的逻辑。 1234for i := 1; i &lt;= 3; i++ &#123; for j := 1; j &lt;= 3; j++ &#123; fmt.Printf(&quot;i: %d, j: %d &quot;, i, j) &#125; 循环配合 defer 使用：在循环中，defer 语句会在当前函数返回之前按照后进先出的顺序执行。 123for i := 0; i &lt; 3; i++ &#123; defer fmt.Println(&quot;延迟执行:&quot;, i)&#125; 在 Go 语言中，字符串是由两部分组成的： 字符串的长度：告诉我们字符串包含多少个字符。 指向字符串内容的指针：指向存储字符串实际字符数据的地方。 指针：它指向字符串数据的实际存储位置。通常，在 64 位系统中，这个指针占用 8 字节。 长度：这是一个整数，用来表示字符串的长度。在 64 位系统中，整数类型通常占用 8 字节。 因此，字符串的总大小计算如下： 指针（8 字节） 长度（8 字节） 8 字节 (指针)+8 字节 (长度)&#x3D;16 字节"}]