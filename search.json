[{"title":"区块链经济学","path":"/2024/11/07/区块链经济学/","content":"宏观经济学解决三大问题：失业、通货、经济增长问题 凯恩斯主义：强调政府在经济中的作用，通过财政&amp;货币政策调节经济周期，增长需求以促进经济增长和减少失业。 主张政府应在经济低迷时通过增加公共支出、减税、扩大货币供应等方式刺激总需求，从而推动经济复苏。 凯恩斯主义失灵： 长期 vs. 短期：凯恩斯主义主要针对短期经济波动，但在长期内，经济增长往往由其他因素（如技术进步、生产力提升）主导，短期政策的有效性可能减弱。 流动性陷阱：在经济低迷时，利率可能降至接近零，消费者和投资者可能对增加支出缺乏信心，导致“流动性陷阱”现象，使得货币政策失去效力。 政府债务问题：凯恩斯主义强调通过政府支出来拉动经济，但长期的大规模赤字可能导致债务水平过高，进而限制未来政府的财政政策空间。 通货膨胀：使用凯恩斯政策刺激经济可能引发通货膨胀，尤其是在经济接近产能极限时，导致成本上升并降低购买力。 市场自我调节能力：一些学者认为市场在自由条件下具有自我调节能力，过度依赖政府干预可能导致市场失灵或资源的非有效配置。 行为经济学的视角：凯恩斯主义假设人们的决策是理性的，但行为经济学研究表明，人们的决策常常受到心理偏差和非理性因素（投资心理：波动&amp;投机）的影响，这可能导致凯恩斯政策的预期效果被削弱。 滞涨危机：经济停滞和通货膨胀经济增长乏力、高通货膨胀、高失业率 在1970年代，政府干预引发的石油危机、供应链问题及其他因素的影响，导致了严重的滞涨现象。 凯恩斯主义主要关注总需求，通过增加政府支出或降低利率来刺激经济。但滞涨往往是由供给侧问题（如能源危机或生产成本上升）引起的，单纯的需求刺激可能无法解决根本问题。 通常认为增加需求会降低失业率，但在滞涨中，增加需求可能会进一步加剧通货膨胀，而无法有效降低失业。 凯恩斯主义政策的实施时间较长，而滞涨危机往往需要迅速的反应。政策滞后可能导致措施出台时，经济形势已发生变化。 实例： 凯恩斯主义认为，通过政府支出可以刺激需求，但在滞涨情况下，这种政策可能会导致更高的通货膨胀而无助于降低失业率。 在1990年代，尽管日本政府采取了扩张性财政政策和货币政策，但经济长期停滞，消费和投资未能恢复。这表明简单的刺激措施并不足以解决深层的结构性问题。 在2008金融危机后，许多国家采取了大规模的刺激政策。然而，尽管短期内经济有所恢复，但长期的经济增长和就业改善却未如预期。部分经济学家认为，结构性改革的不足使得凯恩斯主义政策效果受到限制。 在一些国家（如日本和欧洲），央行尝试通过负利率来刺激经济。然而，实际效果往往不如预期，银行和消费者对借贷的反应不积极，导致经济增长乏力。 反对凯恩斯主义 ：解决石油危机供给学派经济增长是由供给因素（如生产要素的数量和质量）驱动的，强调降低税收和减少监管，以激励企业投资和增加生产，限制政府的财政支出，尤其是福利政策，以减少对市场的干预。关注长期经济增长，而非短期需求刺激。 供给学派质疑凯恩斯主义的短期刺激措施可能导致长期的通货膨胀和低效的资源配置。 里根经济学（Reganomics）：1980年代美国总统里根实施的经济政策，主要包括减税、减少政府干预和扩大市场自由。 货币学派认为货币供应量是影响经济活动的关键因素，控制货币供应是控制通货膨胀和促进经济增长的主要手段。 与凯恩斯主义的需求管理政策不同，货币学派反对政府对经济进行过度干预，主张中央银行应专注于稳定货币供应，防止通货膨胀。 货币学派主张，经济波动主要由货币供给的变化造成，而凯恩斯主义则过于强调需求方因素。认为凯恩斯主义强调的财政政策效果有限，且可能导致无法控制的通货膨胀。 保罗·沃尔克的货币政策：1980年代，时任美联储主席的保罗·沃尔克通过提高利率来控制高通货膨胀 奥地利经济学派奥地利学派主张强烈反对任何形式的政府干预，反对中央银行的货币政策和政府的财政刺激措施。他们认为政府的干预会扰乱市场价格机制，导致资源错配和长期的经济扭曲，认为市场可以通过自发的秩序实现资源的最优配置。 商品的价值取决于消费者对该商品的需求和欲望，而不是生产者投入的劳动或资本。 奥地利经济学派认为，市场是一种复杂的自发秩序，能够通过价格机制引导资源的最优分配。价格反映了供需之间的动态平衡，能有效协调无数个体的决策，而无需政府的中央规划。 强调人类行为的主观性，认为每个个体的行动是根据主观的目标和偏好做出的，而这些目标和偏好是动态和不可量化的。 不认为人类行为可以完全理性化，也反对将人类行为简化为纯粹的数学模型。个体根据其主观判断和有限的信息做出决策，因此不总是“理性”的。 哈耶克《货币的非国家化》 货币竞争：政府垄断货币发行的结果往往是通货膨胀、货币贬值和经济失衡。相反，如果允许私人机构或市场参与发行货币，货币的价值将更稳定，因为不受政治干预，市场会选择最可靠和最有价值的货币。 去中心化货币发行：他主张由多个机构发行不同的货币，然后让消费者和市场决定哪个货币最能保持其购买力，或者说哪个货币最值得信任。这与现代市场中的产品竞争类似，竞争会迫使货币发行者保持货币的稳定性，否则他们的货币将不被市场接受。 对抗通货膨胀：国家发行的货币受制于政治压力，政府为了短期经济或政治利益，可能会超发货币，导致通货膨胀。而在市场竞争下，发行货币的机构将有强烈的动机保持货币的稳定性，否则市场会抛弃他们的货币。 自由市场货币：哈耶克的理想是货币应该完全由自由市场来管理，而不是由政府控制。市场通过自由竞争和选择，能够自动淘汰劣质货币，选出最优的货币系统。 去中心化与竞争：哈耶克主张多种货币竞争，而比特币作为一种去中心化的数字货币，与政府发行的法定货币形成竞争。在比特币诞生后，还出现了许多其他加密货币，它们共同参与了市场上的货币竞争。这种货币的多样性和竞争性正符合哈耶克的设想。 抗通货膨胀：哈耶克担心政府会通过货币超发导致通货膨胀，而比特币的固定供应量设计正是为了解决这个问题。比特币的设计从根本上防止了货币发行的随意性，符合哈耶克对稳定货币的要求。 去中心化管理：哈耶克的理论认为货币发行应当去中心化，由多个机构竞争。虽然比特币本身没有多个发行者，但它通过区块链技术实现了去中心化的管理，全球数以万计的节点共同维护网络，避免了任何单一实体的控制。 市场驱动的货币选择：在哈耶克的理论中，市场是货币选择的最终决定者，而比特币通过市场力量逐渐获得了认可，尤其是在那些不信任政府或中央银行的地方。市场上的个人和企业可以自由选择使用比特币或其他货币，形成了哈耶克式的货币竞争环境。 《国民经济学原理》提出了边际效用的概念，解释了为什么随着物品数量的增加，个体对它的评价会逐渐递减。这一理论对商品价格的形成机制作出了重要的贡献。强调经济行为是由个体的主观选择驱动的，经济学应当从个体行为的分析出发，而不是从宏观的、整体的经济模型出发。 《人的行动》主张经济学的核心在于理解人类的有目的行为。认为人类的行动都是基于主观的偏好和目的，经济现象的本质是人类行动的结果。而不是依赖数学模型和统计分析。 《美国大萧条》罗斯巴德认为，美联储在1920年代通过人为的低利率和货币扩张，导致了金融市场的泡沫，这直接引发了1929年的股市崩盘和随后的大萧条。 社会主义计划经济存在一个关键的理论缺陷，即信息问题。这是奥地利学派对社会主义和计划经济的一个核心批判。 信息的分散性：在一个自由市场中，价格是供需关系的反映，而供需关系又是个体决策的结果。市场价格包含了关于资源的稀缺性、生产和需求的丰富信息。米塞斯和哈耶克认为，在计划经济中，中央计划者无法有效地获取和处理这些分散在社会中的信息。 无法有效分配资源：计划经济中的中央计划者试图通过集中管理经济来分配资源，但他们无法掌握市场中无数个体的需求和偏好，因为这些信息是分散和动态变化的。没有价格机制，中央计划者无法知道该生产多少、如何分配、消费者真正想要什么，这将导致资源错配和经济低效。 哈耶克的“知识问题”：弗里德里希·哈耶克进一步发展了米塞斯的观点，提出了“知识问题”，即市场中的知识是分散的，中央计划者无法集中所有必要的信息进行有效的经济决策。因此，哈耶克认为自由市场是最有效的经济体系，因为它能够通过价格机制利用分散的信息进行资源分配。 货币危机","tags":["blockchain"],"categories":["web3"]},{"title":"PicGo+Github搭建图床","path":"/2024/11/06/PicGo-Github搭建图床/","content":"安装PicGohttps://github.com/Molunerfinn/PicGo/releases 安装完在桌面点了好几次没反应，反复卸载，最后看文档才发现是在状态栏处打开。 https://picgo.github.io/PicGo-Doc/zh/guide/#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85 配置GitHub仓库为了使用GitHub作为图床，你需要一个GitHub仓库来存放图片，确保仓库的权限设置为公开，这样别人才能访问你的图片。 生成Personal Access Token (PAT)为了使PicGo能够访问你的GitHub仓库，你需要生成一个Personal Access Token： 登录你的GitHub账户。 访问设置页面，找到“Developer settings”部分。 在“Personal access tokens”中生成一个新的访问令牌。 确保你的访问令牌具有足够的权限来推送到仓库（至少需要repo权限）。 生成后，确保复制并保存你的访问令牌，因为它不会再次显示。 配置PicGo 在PicGo的设置中找到“图床设置”。 选择“GitHub”作为图床服务。 输入你的GitHub仓库名称（格式为username/repo）。 输入你的Personal Access Token。 配置分支名称，默认为main或master。 配置路径前缀，这是你图片存放在GitHub仓库中的目录路径。 保存设置。 PicGo 插件https://github.com/PicGo/Awesome-PicGo vscode-migrator 0.0.2 功能：从 Visual Studio Code 的图片上传插件（如 PicGo 的 VS Code 插件）导入图片。 quick-capture 1.0.0-alpha.2 功能：一个快速截图插件，用于 PicGo，允许用户快速捕捉屏幕并上传图片。 https://github.com/PicGo/picgo-plugin-quick-capture 点击链接看教程 pic-migrator 1.3.2 功能：一个 PicGo 插件，用于在 Markdown 文件中迁移图片链接。 super-prefix 1.2.2 功能：一个 PicGo 插件，用于为上传的文件名添加优雅的前缀。 https://github.com/gclove/picgo-plugin-super-prefix#readme Picgo-plugin-clipboard 功能：允许你将剪贴板中的图片直接上传到配置的图床 可以愉快的使用了","tags":["PicGo","Github"],"categories":["工具"]},{"title":"Git学习","path":"/2024/11/06/Git学习/","content":"Git原理123代码块1代码块2代码块3 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;void dfs()&#123; // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;&#125;int main()&#123; dfs(); return 0;&#125;","tags":["Git"]},{"title":"Hello World","path":"/2024/11/06/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartHEXO无后端运维和高速渲染页面是静态站点生成器,我使用了 Github Pages 和 Vercel 来部署博客 Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"Markdown格式","path":"/2024/10/11/Markdown/","content":"123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 一级标题二级标题三级标题四级标题五级标题六级标题1###### tags: `This is tag` tags: This is tag列表无序列表：*，+，- 表示无序列表。注意：符号后面一定要有一个空格，起到缩进的作用 123- 列表1 - 列表2- 列表3 列表1 列表2 列表3 有序列表：英文句点后面一定要有一个空格 1231. 列表12. 列表23. 列表3 列表1 列表2 列表3 123&gt; 引用1&gt; 引用2&gt; 引用3 引用1引用2引用3 1 代码块 1 123代码块1代码块2代码块3 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;void dfs()&#123; // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;&#125;int main()&#123; dfs(); return 0;&#125; 123![图片描述](https://www.example.com/image.jpg) 点击图片可放大1&#123;% image /路径/路径.jpg %&#125; 插入链接12[链接](URL_ADDRESS) markdown教程 强调语法12345678*斜体文本*_斜体文本_**粗体文本**__粗体文本__**_同时斜体和粗体_** 斜体文本斜体文本 粗体文本粗体文本 同时斜体和粗体 任务列表123- [x] 已完成项- [ ] 未完成项 已完成项 未完成项 表格123456| 表头 | 表头 || ---- | ---- || 单元 | 单元 || 单元 | 单元 | 表头 表头 单元 单元 单元 单元 水平分隔线1234567三个或三个以上的符号，必须在独立的一行，前后不能有其他文字--- 短横线***星号___下短线 短横线 星号 下短线","tags":["Markdown"],"categories":["工具"]},{"title":"about","path":"/about/index.html","content":"GinaA lifelong journey of learning and creating"},{"path":"/js/adjust-codeblock-height.js","content":"// 给超长代码块增加滚动条 function adjustCodeBlockHeight() { document.addEventListener(\"DOMContentLoaded\", function () { // 选择所有的.md-text元素 var codeBlocks = document.querySelectorAll('.md-text'); // 遍历每个.md-text元素 codeBlocks.forEach(function (block) { // 检查是否包含.highlight类的子元素，且父元素高度超过500px var highlightBlocks = block.querySelectorAll('.highlight'); highlightBlocks.forEach(function (highlightBlock) { if (highlightBlock.clientHeight > 100) { highlightBlock.style.maxHeight = '300px'; highlightBlock.style.overflow = 'auto'; } }); }); }); } adjustCodeBlockHeight()"},{"path":"/js/l2d.js","content":"addEventListener(\"DOMContentLoaded\", function () { let models = [ { width: 230, height: 350, bottom: \"0px\", right: \"0px\", role: \"https://cdn.jsdelivr.net/gh/imuncle/live2d@master/model/snow_miku/model.json\", background: \"\", opacity: 1, mobile: false, draggable: false, scale: 0.07, }, ]; new Live2dLoader(models); });"},{"path":"/js/chatgpt.js","content":"function ChucklePostAI(config) { // 获取要插入 AI 的文章容器 function getArticleContainer() { let container = null; if (!config.auto_mount && config.el) { container = document.querySelector( config.el || \"#post #article-container\" ); } return container || findLargestContentElement(); } // 计算一个元素的子元素的数量 function countChildElements(element) { let count = 1; Array.from(element.children).forEach((child) => { count += countChildElements(child); }); return count; } // 检查一个元素是否应被排除（如 iframe、footer 等） function shouldExcludeElement(element) { const tagBlacklist = [\"IFRAME\", \"FOOTER\", \"HEADER\", \"BLOCKQUOTE\"]; const classBlacklist = [\"aplayer\", \"comment\"]; return ( tagBlacklist.includes(element.tagName) || Array.from(element.classList).some((className) => classBlacklist.some((cls) => className.includes(cls)) ) ); } // 查找内容最多的 DOM 元素 function findLargestContentElement() { const rootElement = findRootElement(); return findLargestElementInTree(rootElement); } // 查找内容最多的根元素 function findRootElement() { const elementsToCheck = [document.body]; let rootElement = null; let maxCount = 0; while (elementsToCheck.length > 0) { const element = elementsToCheck.shift(); if (shouldExcludeElement(element)) continue; const childCount = countChildElements(element); if (childCount > maxCount) { maxCount = childCount; rootElement = element; } Array.from(element.children).forEach((child) => { elementsToCheck.push(child); }); } return rootElement; } // 查找最大的 DOM 元素 function findLargestElementInTree(rootElement) { const weightMap = { H1: 1.5, H2: 1, H3: 0.5, P: 1 }; let maxWeight = 0; let largestElement = null; function calculateWeight(element) { if (shouldExcludeElement(element)) return; let elementWeight = Array.from(element.children).reduce( (weight, child) => { return weight + (weightMap[child.tagName] || 0); }, 0 ); if (elementWeight > maxWeight) { maxWeight = elementWeight; largestElement = element; } Array.from(element.children).forEach(calculateWeight); } calculateWeight(rootElement); return largestElement; } // 创建并插入 AI 的 UI 元素 function createAIElement() { const aiContainer = document.createElement(\"div\"); aiContainer.className = \"post-ai\"; aiContainer.id = \"post-ai\"; aiContainer.style.cssText = ` margin: 30px 0; `; const aiInterface = { name: \"文章辅助AI\", introduce: \"我是文章辅助AI，点击下方的按钮，让我生成本文简介\", version: \"gpt-3.5-turbo-16k\", buttons: [\"介绍自己\", \"生成摘要\"], ...config.interface, }; aiContainer.innerHTML = ` ${aiInterface.name} 切换简介 ${aiInterface.version} ${aiInterface.name}初始化中... ${aiInterface.buttons .map((btn) => `${btn}`) .join(\"\")} `; bindButtonEvents(aiContainer); const articleContainer = getArticleContainer(); if (articleContainer) { articleContainer.insertBefore(aiContainer, articleContainer.firstChild); } disableButtons(aiContainer); // 禁用按钮 generateSummary(aiContainer); // 初始化时生成文章摘要 } // 绑定按钮事件 function bindButtonEvents(aiContainer) { const generateIntroductionButton = aiContainer.querySelector( \".ai-btn-item:first-child\" ); const generateSummaryButton = aiContainer.querySelector( \".ai-btn-item:last-child\" ); generateIntroductionButton.addEventListener(\"click\", () => { disableButtons(aiContainer); // 禁用按钮 displaySummary( \"我是文章辅助AI，使用的OpenAI的gpt-3.5-turbo, embedding, gpt-4o-mini, gpt-4模型。点击下方的按钮，让我生成本文简介。\", aiContainer ); }); generateSummaryButton.addEventListener(\"click\", () => { disableButtons(aiContainer); // 禁用按钮 generateSummary(aiContainer); // 将 aiContainer 传递给 generateSummary }); } // 禁用所有按钮 function disableButtons(aiContainer) { const buttons = aiContainer.querySelectorAll(\".ai-btn-item\"); buttons.forEach((button) => { button.disabled = true; button.style.pointerEvents = \"none\"; // 禁用点击事件 button.style.opacity = \"0.5\"; // 调整按钮的透明度 }); } // 启用所有按钮 function enableButtons(aiContainer) { const buttons = aiContainer.querySelectorAll(\".ai-btn-item\"); buttons.forEach((button) => { button.disabled = false; button.style.pointerEvents = \"auto\"; // 允许点击事件 button.style.opacity = \"1\"; // 恢复按钮的透明度 }); } // 生成文章摘要 async function generateSummary(aiContainer) { const content = getArticleContent(); const apiKey = \"sk-X0SGzTCLenEtBroX1Nm5nItG1iYP32zAtUKyyT2im62MYWFD\"; // 请替换为你的实际 API KEY const requestBody = { model: \"gpt-3.5-turbo-16k\", messages: [ { role: \"system\", content: \"请为下面的内容生成摘要，以本文讲述了开头，不要出现任何与文章无关的内容。\", }, { role: \"user\", content: content }, ], temperature: 0, }; try { const response = await fetch(\"https://api.chatanywhere.tech\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\", Authorization: `Bearer ${apiKey}`, }, body: JSON.stringify(requestBody), }); if (!response.ok) { throw new Error(\"网络响应不是 OK\"); } const data = await response.json(); displaySummary(data.choices[0].message.content, aiContainer); console.log(\"摘要生成成功:\", data.choices[0].message.content); } catch (error) { console.error(\"请求失败:\", error); } } // 获取文章内容 function getArticleContent() { const articleContainer = getArticleContainer(); return articleContainer ? articleContainer.innerText : \"\"; // 获取文章的文本内容 } // 显示生成的摘要（添加打字机效果） function displaySummary(summary, aiContainer) { const aiSpeechContent = document.querySelector(\".ai-explanation\"); if (aiSpeechContent) { aiSpeechContent.innerText = \"\"; // 清空之前的内容 typeWriterEffect(aiSpeechContent, summary, 15, aiContainer); // 逐字显示摘要 } } // 打字机效果 function typeWriterEffect(element, text, delay, aiContainer) { let index = 0; function type() { if (index < text.length) { element.innerText += text.charAt(index); index++; setTimeout(type, delay); } else { enableButtons(aiContainer); // 打字效果结束后启用按钮 } } type(); } // 初始化函数 function initialize() { createAIElement(); } initialize(); }"},{"title":"Go基本语法","path":"/wiki/Go/基本语法/index.html","content":"在 Go 语言中，字符串是由两部分组成的： 字符串的长度：告诉我们字符串包含多少个字符。 指向字符串内容的指针：指向存储字符串实际字符数据的地方。 指针：它指向字符串数据的实际存储位置。通常，在 64 位系统中，这个指针占用 8 字节。 长度：这是一个整数，用来表示字符串的长度。在 64 位系统中，整数类型通常占用 8 字节。 因此，字符串的总大小计算如下： 指针（8 字节） 长度（8 字节） 8 字节 (指针)+8 字节 (长度)&#x3D;16 字节 Go 内存区域划分 Go 语言中，内存通常分为三大区域： 全局静态区：存储全局变量和常量。这些变量和常量在程序启动时分配内存，并在程序结束时释放。 就像是家里的储藏室，存放不常变动的东西。 堆：存储动态分配的内存，通常用于需要在多个函数间共享的对象。堆上的数据需要手动管理或由 Go 的垃圾回收机制负责清理。 就像是客厅，存放大家共用的大件物品，需要定期打扫。 栈：用于函数调用时 就像是临时操作台，每次做饭（函数调用）时使用，做完饭后就清理。 在Go语言中，逃逸分析（escape analysis）是一种编译期优化技术，用于确定局部变量的存储位置。如果变量只在当前函数内部使用，并且没有被传递到其他函数或goroutine，那么这个变量通常存储在栈（stack）上。如果变量的生命周期超出了当前函数，比如被返回或传递给了其他goroutine，那么这个变量就会“逃逸”到堆（heap）上。 让我们用大白话来解释一下这个过程： 逃逸分析是什么？逃逸分析就像是侦探工作，编译器像侦探一样，追踪每个局部变量的去向。如果变量只在当前函数内部使用，那么它就老老实实地呆在栈上。但如果变量被带出了当前函数，比如被函数返回，或者被发送到另一个goroutine，那么它就需要一个更长久的家——堆。 为什么变量会逃逸到堆上？ 变量被返回： 如果一个变量的地址被返回，那么它可能被其他函数长时间持有，所以它需要存储在堆上，以免在函数返回后被销毁。 变量被传递给goroutine： 如果一个变量被传递给一个新的goroutine，那么它的生命周期就不再局限于当前函数，它需要在堆上分配内存，以确保在goroutine执行期间变量仍然有效。 什么时候会发生： 如果局部变量的生命周期超出了它所在的函数，比如被函数返回或者被传递给了其他的goroutine，那么它就需要一个更长久的存储位置，这时候它就会“逃逸”到堆上。 堆的作用： 堆就像是家里的储藏室，用来存放那些需要长时间保存的东西。在Go语言中，当局部变量逃逸到堆上时，就意味着它们被分配在堆上，可以被程序的其他部分长期访问。"}]